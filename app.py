import streamlit as st
import random
import string
import secrets
import hashlib
import re
import json
from datetime import datetime, timedelta
import pandas as pd
import time

# Configuraci√≥n de la p√°gina
st.set_page_config(
  page_title="üîê SmartPass AI",
  page_icon="üîê",
  layout="wide",
  initial_sidebar_state="expanded"
)

# CSS personalizado
st.markdown("""
<style>
  .main-header {
      text-align: center;
      background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
      padding: 2rem;
      border-radius: 10px;
      margin-bottom: 2rem;
      color: white;
  }
  .password-display {
      background-color: #f0f2f6;
      padding: 1rem;
      border-radius: 8px;
      border-left: 4px solid #667eea;
      font-family: 'Courier New', monospace;
      font-size: 1.2rem;
      margin: 1rem 0;
      word-break: break-all;
  }
  .progress-bar {
      background-color: #f0f0f0;
      border-radius: 10px;
      padding: 3px;
      margin: 10px 0;
  }
  .progress-fill {
      height: 20px;
      border-radius: 8px;
      transition: width 0.3s;
      text-align: center;
      line-height: 20px;
      color: white;
      font-weight: bold;
      font-size: 12px;
  }
  .tip-box {
      background-color: #fff3cd;
      border: 1px solid #ffeaa7;
      border-radius: 8px;
      padding: 1rem;
      margin: 1rem 0;
  }
  .success-box {
      background-color: #d4edda;
      border: 1px solid #c3e6cb;
      border-radius: 8px;
      padding: 1rem;
      margin: 1rem 0;
  }
</style>
""", unsafe_allow_html=True)

# Clases para el generador de contrase√±as
class PasswordGenerator:
  def __init__(self):
      self.common_words = [
          'casa', 'perro', 'gato', 'sol', 'luna', 'mar', 'monta√±a', 'r√≠o',
          'flor', '√°rbol', 'cielo', 'estrella', 'fuego', 'agua', 'tierra',
          'viento', 'luz', 'sombra', 'tiempo', 'espacio', 'm√∫sica', 'arte',
          'libro', 'puerta', 'ventana', 'camino', 'jard√≠n', 'bosque'
      ]
      self.animals = [
          'le√≥n', 'tigre', '√°guila', 'delf√≠n', 'lobo', 'oso', 'zorro',
          'ciervo', 'b√∫ho', 'halc√≥n', 'puma', 'jaguar', 'c√≥ndor', 'ballena',
          'elefante', 'jirafa', 'cebra', 'rinoceronte', 'hipop√≥tamo'
      ]
      self.colors = [
          'azul', 'rojo', 'verde', 'amarillo', 'p√∫rpura', 'naranja',
          'rosa', 'negro', 'blanco', 'dorado', 'plateado', 'turquesa',
          'violeta', '√≠ndigo', 'coral', 'esmeralda', 'rub√≠', 'zafiro'
      ]
      
  def generate_classic(self, length=12, use_uppercase=True, use_lowercase=True, 
                      use_numbers=True, use_symbols=True, exclude_ambiguous=False):
      """Genera contrase√±a cl√°sica aleatoria"""
      chars = ""
      if use_lowercase:
          chars += string.ascii_lowercase
      if use_uppercase:
          chars += string.ascii_uppercase
      if use_numbers:
          chars += string.digits
      if use_symbols:
          chars += "!@#$%^&*()_+-=[]{}|;:,.<>?"
          
      if exclude_ambiguous:
          ambiguous = "0O1lI|"
          chars = ''.join(c for c in chars if c not in ambiguous)
          
      if not chars:
          chars = string.ascii_letters + string.digits
          
      return ''.join(secrets.choice(chars) for _ in range(length))
  
  def generate_memorable(self, num_words=3, separator='-', add_numbers=True, capitalize=True):
      """Genera contrase√±a memorable con palabras"""
      all_words = self.common_words + self.animals + self.colors
      words = random.sample(all_words, min(num_words, len(all_words)))
      
      if capitalize:
          words = [word.capitalize() for word in words]
          
      password = separator.join(words)
      
      if add_numbers:
          password += separator + str(random.randint(1000, 9999))
          
      return password
  
  def generate_contextual(self, context, length=14):
      """Genera contrase√±a seg√∫n contexto usando 'IA simulada'"""
      context_patterns = {
          'banking': {
              'prefix': ['Bank', 'Secure', 'Safe', 'Trust', 'Vault', 'Guard'],
              'symbols': ['$', '#', '@', '&', '!'],
              'numbers': True,
              'complexity': 'high'
          },
          'social_media': {
              'prefix': ['Social', 'Connect', 'Share', 'Like', 'Follow', 'Post'],
              'symbols': ['!', '@', '#'],
              'numbers': True,
              'complexity': 'medium'
          },
          'work': {
              'prefix': ['Work', 'Office', 'Pro', 'Team', 'Project', 'Task'],
              'symbols': ['-', '_', '.', '#'],
              'numbers': True,
              'complexity': 'medium'
          },
          'gaming': {
              'prefix': ['Game', 'Play', 'Win', 'Epic', 'Hero', 'Quest'],
              'symbols': ['!', '@', '#', '*', '+'],
              'numbers': True,
              'complexity': 'medium'
          },
          'email': {
              'prefix': ['Mail', 'Email', 'Msg', 'Send', 'Inbox', 'Letter'],
              'symbols': ['.', '@', '_', '-'],
              'numbers': True,
              'complexity': 'medium'
          }
      }
      
      pattern = context_patterns.get(context, context_patterns['work'])
      
      # Simular procesamiento de IA
      with st.spinner(f"ü§ñ Analizando contexto '{context}'..."):
          time.sleep(0.8)
      
      # Construir contrase√±a contextual
      prefix = random.choice(pattern['prefix'])
      word = random.choice(self.common_words).capitalize()
      
      base = prefix + word
      
      if pattern['numbers']:
          base += str(random.randint(100, 999))
          
      base += random.choice(pattern['symbols'])
      base += str(datetime.now().year)
      
      # Ajustar longitud
      while len(base) < length:
          base += random.choice(string.ascii_letters + string.digits)
          
      return base[:length]
  
  def generate_passphrase(self, num_words=5, language='spanish'):
      """Genera frase de contrase√±a"""
      if language == 'spanish':
          all_words = self.common_words + self.animals + self.colors
          words = random.sample(all_words, min(num_words, len(all_words)))
      else:
          english_words = ['house', 'dog', 'sun', 'tree', 'music', 'ocean', 'mountain', 'star']
          words = random.sample(english_words, min(num_words, len(english_words)))
          
      return ' '.join(word.capitalize() for word in words)

class SecurityAnalyzer:
  def __init__(self):
      self.common_passwords = [
          '123456', 'password', '123456789', '12345678', '12345',
          '1234567', '1234567890', 'qwerty', 'abc123', 'password123',
          'admin', 'letmein', 'welcome', 'monkey', 'dragon'
      ]
  
  def analyze_strength(self, password):
      """Analiza la fortaleza de la contrase√±a"""
      score = 0
      feedback = []
      
      # Longitud
      if len(password) >= 16:
          score += 30
      elif len(password) >= 12:
          score += 25
      elif len(password) >= 8:
          score += 15
          feedback.append("üí° Considera usar al menos 12 caracteres")
      else:
          score += 5
          feedback.append("‚ö†Ô∏è Muy corta - usa al menos 8 caracteres")
      
      # Variedad de caracteres
      if re.search(r'[a-z]', password):
          score += 10
      else:
          feedback.append("üìù A√±ade letras min√∫sculas")
          
      if re.search(r'[A-Z]', password):
          score += 10
      else:
          feedback.append("üî§ A√±ade letras may√∫sculas")
          
      if re.search(r'\d', password):
          score += 15
      else:
          feedback.append("üî¢ A√±ade n√∫meros")
          
      if re.search(r'[!@#$%^&*()_+\-=\[\]{}|;:,.<>?]', password):
          score += 20
      else:
          feedback.append("üî£ A√±ade s√≠mbolos especiales")
      
      # Penalizaciones
      if password.lower() in [p.lower() for p in self.common_passwords]:
          score -= 40
          feedback.append("‚ùå Evita contrase√±as muy comunes")
      
      if re.search(r'123|abc|qwe|password', password.lower()):
          score -= 15
          feedback.append("üö´ Evita secuencias obvias")
          
      # Bonificaciones
      if len(set(password)) > len(password) * 0.7:
          score += 10
          
      if not re.search(r'(.)\1{2,}', password):
          score += 5
      else:
          feedback.append("üîÑ Evita repetir caracteres consecutivos")
      
      score = max(0, min(100, score))
      
      if score >= 90:
          strength = "Excelente"
          color = "#28a745"
          emoji = "üõ°Ô∏è"
      elif score >= 75:
          strength = "Muy Fuerte"
          color = "#20c997"
          emoji = "üîí"
      elif score >= 60:
          strength = "Fuerte"
          color = "#17a2b8"
          emoji = "üîê"
      elif score >= 40:
          strength = "Moderada"
          color = "#ffc107"
          emoji = "‚ö†Ô∏è"
      else:
          strength = "D√©bil"
          color = "#dc3545"
          emoji = "‚ùå"
          
      return {
          'score': score,
          'strength': strength,
          'color': color,
          'emoji': emoji,
          'feedback': feedback,
          'estimated_crack_time': self.estimate_crack_time(score),
          'entropy': self.calculate_entropy(password)
      }
  
  def estimate_crack_time(self, score):
      """Estima tiempo de cracking"""
      if score >= 90:
          return "Trillones de a√±os"
      elif score >= 75:
          return "Millones de a√±os"
      elif score >= 60:
          return "Miles de a√±os"
      elif score >= 40:
          return "Meses a a√±os"
      else:
          return "Minutos a d√≠as"
  
  def calculate_entropy(self, password):
      """Calcula la entrop√≠a de la contrase√±a"""
      charset_size = 0
      if re.search(r'[a-z]', password):
          charset_size += 26
      if re.search(r'[A-Z]', password):
          charset_size += 26
      if re.search(r'\d', password):
          charset_size += 10
      if re.search(r'[!@#$%^&*()_+\-=\[\]{}|;:,.<>?]', password):
          charset_size += 32
          
      if charset_size == 0:
          return 0
          
      import math
      entropy = len(password) * math.log2(charset_size)
      return round(entropy, 1)

# Inicializar objetos
if 'generator' not in st.session_state:
  st.session_state.generator = PasswordGenerator()
if 'analyzer' not in st.session_state:
  st.session_state.analyzer = SecurityAnalyzer()
if 'password_history' not in st.session_state:
  st.session_state.password_history = []

# Header principal
st.markdown("""
<div class="main-header">
  <h1>üîê SmartPass AI</h1>
  <h3>Generador Inteligente de Contrase√±as</h3>
  <p>Crea contrase√±as seguras y personalizadas con inteligencia artificial</p>
</div>
""", unsafe_allow_html=True)

# Sidebar - Configuraci√≥n
st.sidebar.markdown("## ‚öôÔ∏è Configuraci√≥n")

# Selector de modo
mode = st.sidebar.selectbox(
  "üéØ Modo de Generaci√≥n",
  ["üé≤ Cl√°sico", "üß† IA Contextual", "üí≠ Memorable", "üìù Frase de Contrase√±a"]
)

st.sidebar.markdown("---")

# Configuraciones espec√≠ficas seg√∫n el modo
if mode == "üé≤ Cl√°sico":
  st.sidebar.markdown("### üé≤ Configuraci√≥n Cl√°sica")
  length = st.sidebar.slider("Longitud", 8, 50, 16)
  use_uppercase = st.sidebar.checkbox("May√∫sculas (A-Z)", True)
  use_lowercase = st.sidebar.checkbox("Min√∫sculas (a-z)", True)
  use_numbers = st.sidebar.checkbox("N√∫meros (0-9)", True)
  use_symbols = st.sidebar.checkbox("S√≠mbolos (!@#$...)", True)
  exclude_ambiguous = st.sidebar.checkbox("Excluir ambiguos (0,O,1,l,I)", False)

elif mode == "üß† IA Contextual":
  st.sidebar.markdown("### üß† Configuraci√≥n IA")
  context = st.sidebar.selectbox(
      "Contexto de Uso",
      ["banking", "social_media", "work", "gaming", "email"]
  )
  length = st.sidebar.slider("Longitud", 10, 30, 16)
  
  # Informaci√≥n del contexto
  context_info = {
      "banking": "üè¶ M√°xima seguridad para servicios financieros",
      "social_media": "üì± Optimizada para redes sociales",
      "work": "üíº Profesional y f√°cil de escribir",
      "gaming": "üéÆ Creativa para plataformas de juegos",
      "email": "üìß Balanceada para correo electr√≥nico"
  }
  st.sidebar.info(context_info[context])

elif mode == "üí≠ Memorable":
  st.sidebar.markdown("### üí≠ Configuraci√≥n Memorable")
  num_words = st.sidebar.slider("N√∫mero de palabras", 2, 6, 3)
  separator = st.sidebar.selectbox("Separador", ["-", "_", ".", " ", ""])
  add_numbers = st.sidebar.checkbox("A√±adir n√∫meros", True)
  capitalize = st.sidebar.checkbox("Capitalizar palabras", True)

else:  # Frase de contrase√±a
  st.sidebar.markdown("### üìù Configuraci√≥n Frase")
  num_words = st.sidebar.slider("N√∫mero de palabras", 4, 8, 5)
  language = st.sidebar.selectbox("Idioma", ["spanish", "english"])

st.sidebar.markdown("---")

# Configuraciones adicionales
st.sidebar.markdown("### üõ°Ô∏è Opciones de Seguridad")
auto_analyze = st.sidebar.checkbox("An√°lisis autom√°tico", True)
show_strength_meter = st.sidebar.checkbox("Mostrar medidor de fuerza", True)

# Layout principal
col1, col2 = st.columns([2, 1])

with col1:
  st.markdown("## üöÄ Generador de Contrase√±as")
  
  # Bot√≥n principal de generaci√≥n
  if st.button("üéØ Generar Contrase√±a", type="primary", use_container_width=True):
      try:
          if mode == "üé≤ Cl√°sico":
              password = st.session_state.generator.generate_classic(
                  length, use_uppercase, use_lowercase, use_numbers, 
                  use_symbols, exclude_ambiguous
              )
          elif mode == "üß† IA Contextual":
              password = st.session_state.generator.generate_contextual(context, length)
          elif mode == "üí≠ Memorable":
              password = st.session_state.generator.generate_memorable(
                  num_words, separator, add_numbers, capitalize
              )
          else:  # Frase de contrase√±a
              password = st.session_state.generator.generate_passphrase(num_words, language)
          
          # Analizar autom√°ticamente si est√° habilitado
          analysis = None
          if auto_analyze:
              analysis = st.session_state.analyzer.analyze_strength(password)
          
          # Guardar en historial
          st.session_state.password_history.append({
              'password': password,
              'mode': mode,
              'timestamp': datetime.now(),
              'analysis': analysis
          })
          
          st.session_state.current_password = password
          st.session_state.current_analysis = analysis
          
      except Exception as e:
          st.error(f"Error al generar contrase√±a: {str(e)}")
  
  # Mostrar contrase√±a generada
  if hasattr(st.session_state, 'current_password'):
      st.markdown("### üîë Contrase√±a Generada")
      
      # Display de la contrase√±a
      st.markdown(f"""
      <div class="password-display">
          <strong>{st.session_state.current_password}</strong>
      </div>
      """, unsafe_allow_html=True)
      
      # Botones de acci√≥n
      col_copy, col_regenerate, col_analyze, col_clear = st.columns(4)
      
      with col_copy:
          if st.button("üìã Copiar", use_container_width=True):
              st.success("‚úÖ ¬°Copiado!")
              st.balloons()
      
      with col_regenerate:
          if st.button("üîÑ Regenerar", use_container_width=True):
              st.rerun()
      
      with col_analyze:
          if st.button("üîç Analizar", use_container_width=True):
              analysis = st.session_state.analyzer.analyze_strength(st.session_state.current_password)
              st.session_state.current_analysis = analysis
              st.rerun()
      
      with col_clear:
          if st.button("üóëÔ∏è Limpiar", use_container_width=True):
              if hasattr(st.session_state, 'current_password'):
                  del st.session_state.current_password
              if hasattr(st.session_state, 'current_analysis'):
                  del st.session_state.current_analysis
              st.rerun()
      
      # An√°lisis de fortaleza
      if hasattr(st.session_state, 'current_analysis') and st.session_state.current_analysis:
          analysis = st.session_state.current_analysis
          
          st.markdown("### üìä An√°lisis de Seguridad")
          
          # Medidor de fuerza visual
          if show_strength_meter:
              st.markdown(f"""
              <div class="progress-bar">
                  <div class="progress-fill" style="background-color: {analysis['color']}; width: {analysis['score']}%;">
                      {analysis['score']}/100
                  </div>
              </div>
              """, unsafe_allow_html=True)
          
          # M√©tricas principales
          metric_cols = st.columns(4)
          with metric_cols[0]:
              st.metric("Fortaleza", f"{analysis['emoji']} {analysis['strength']}")
          with metric_cols[1]:
              st.metric("Puntuaci√≥n", f"{analysis['score']}/100")
          with metric_cols[2]:
              st.metric("Entrop√≠a", f"{analysis['entropy']} bits")
          with metric_cols[3]:
              st.metric("Tiempo de Cracking", analysis['estimated_crack_time'])
          
          # Feedback y recomendaciones
          if analysis['feedback']:
              st.markdown("#### üí° Recomendaciones para Mejorar")
              for tip in analysis['feedback']:
                  st.markdown(f"""
                  <div class="tip-box">
                      {tip}
                  </div>
                  """, unsafe_allow_html=True)
          elif analysis['score'] >= 80:
              st.markdown("""
              <div class="success-box">
                  üéâ ¬°Excelente! Esta contrase√±a tiene una seguridad muy alta.
              </div>
              """, unsafe_allow_html=True)

with col2:
  st.markdown("## üìà Panel de Control")
  
  # Botones de generaci√≥n r√°pida
  st.markdown("### ‚ö° Generaci√≥n R√°pida")
  quick_cols = st.columns(2)
  
  with quick_cols[0]:
      if st.button("üé≤ R√°pida", use_container_width=True):
          password = st.session_state.generator.generate_classic(12, True, True, True, True)
          st.session_state.current_password = password
          st.session_state.current_analysis = st.session_state.analyzer.analyze_strength(password)
          st.rerun()
  
  with quick_cols[1]:
      if st.button("üõ°Ô∏è Segura", use_container_width=True):
          password = st.session_state.generator.generate_classic(20, True, True, True, True)
          st.session_state.current_password = password
          st.session_state.current_analysis = st.session_state.analyzer.analyze_strength(password)
          st.rerun()
  
  # Historial reciente
  st.markdown("### üìù Historial Reciente")
  
  if st.session_state.password_history:
      recent_passwords = list(reversed(st.session_state.password_history[-5:]))
      
      for i, entry in enumerate(recent_passwords):
          with st.expander(f"{entry['mode']} - {entry['timestamp'].strftime('%H:%M:%S')}"):
              st.code(entry['password'], language=None)
              if entry.get('analysis'):
                  col_a, col_b = st.columns(2)
                  with col_a:
                      st.caption(f"**Fortaleza:** {entry['analysis']['strength']}")
                  with col_b:
                      st.caption(f"**Puntuaci√≥n:** {entry['analysis']['score']}/100")
              
              if st.button(f"Usar esta", key=f"use_{i}"):
                  st.session_state.current_password = entry['password']
                  st.session_state.current_analysis = entry['analysis']
                  st.rerun()
  else:
      st.info("üìù No hay contrase√±as generadas a√∫n")
  
  # Limpiar historial
  if st.session_state.password_history:
      if st.button("üóëÔ∏è Limpiar Historial", use_container_width=True):
          st.session_state.password_history = []
          st.success("‚úÖ Historial limpiado")
          st.rerun()

# Footer con tabs adicionales
st.markdown("---")

# Tabs adicionales
tab1, tab2, tab3, tab4 = st.tabs(["üõ°Ô∏è Consejos", "üîß Herramientas", "üìö Gu√≠a", "‚ÑπÔ∏è Info"])

with tab1:
  st.markdown("### üõ°Ô∏è Consejos de Seguridad")
  
  col_a, col_b = st.columns(2)
  
  with col_a:
      st.markdown("#### ‚úÖ Buenas Pr√°cticas:")
      st.markdown("""
      - Usar contrase√±as √∫nicas para cada cuenta
      - M√≠nimo 12 caracteres de longitud
      - Combinar may√∫sculas, min√∫sculas, n√∫meros y s√≠mbolos
      - Activar autenticaci√≥n de dos factores (2FA)
      - Usar un gestor de contrase√±as
      - Cambiar contrase√±as comprometidas inmediatamente
      """)
  
  with col_b:
      st.markdown("#### ‚ùå Evitar:")
      st.markdown("""
      - Informaci√≥n personal (nombres, fechas)
      - Contrase√±as comunes (123456, password)
      - Reutilizar contrase√±as entre sitios
      - Compartir por email o mensajes
      - Secuencias obvias (abc123, qwerty)
      - Almacenar en archivos de texto plano
      """)

with tab2:
  st.markdown("### üîß Herramientas Adicionales")
  
  # Verificador de contrase√±as existentes
  st.markdown("#### üîç Analizar Contrase√±a Existente")
  existing_password = st.text_input("Ingresa una contrase√±a para analizar:", type="password")
  
  if existing_password and st.button("Analizar Contrase√±a"):
      analysis = st.session_state.analyzer.analyze_strength(existing_password)
      
      col_a, col_b = st.columns(2)
      with col_a:
          st.metric("Puntuaci√≥n", f"{analysis['score']}/100")
          st.metric("Fortaleza", analysis['strength'])
      with col_b:
          st.metric("Tiempo de Cracking", analysis['estimated_crack_time'])
          st.metric("Longitud", len(existing_password))
      
      if analysis['feedback']:
          st.markdown("**Recomendaciones:**")
          for tip in analysis['feedback']:
              st.warning(f"‚Ä¢ {tip}")
  
  # Generador de m√∫ltiples contrase√±as
  st.markdown("#### üéØ Generaci√≥n en Lote")
  batch_count = st.number_input("Cantidad de contrase√±as", 1, 10, 3)
  
  if st.button("Generar Lote"):
      st.markdown("**Contrase√±as generadas:**")
      for i in range(batch_count):
          password = st.session_state.generator.generate_classic(16, True, True, True, True)
          analysis = st.session_state.analyzer.analyze_strength(password)
          st.code(f"{i+1}. {password} (Fortaleza: {analysis['strength']})")

with tab3:
  st.markdown("### üìö Gu√≠a de Uso")
  
  st.markdown("#### üéØ Modos de Generaci√≥n:")
  
  st.markdown("**üé≤ Modo Cl√°sico**")
  st.markdown("Genera contrase√±as aleatorias tradicionales con control total sobre los caracteres incluidos.")
  
  st.markdown("**üß† Modo IA Contextual**")
  st.markdown("Utiliza inteligencia artificial simulada para crear contrase√±as optimizadas seg√∫n el contexto de uso.")
  
  st.markdown("**üí≠ Modo Memorable**")
  st.markdown("Crea contrase√±as usando palabras comunes que son m√°s f√°ciles de recordar.")
  
  st.markdown("**üìù Modo Frase de Contrase√±a**")
  st.markdown("Genera frases completas que son seguras y relativamente f√°ciles de recordar.")

with tab4:
  st.markdown("### ‚ÑπÔ∏è Acerca de SmartPass AI")
  
  st.markdown("""
  **SmartPass AI** es un generador de contrase√±as inteligente que combina algoritmos 
  de seguridad criptogr√°fica con inteligencia artificial para crear contrase√±as 
  seguras y personalizadas.
  
  #### üîß Caracter√≠sticas:
  - Generaci√≥n criptogr√°ficamente segura
  - An√°lisis de fortaleza multi-criterio
  - IA contextual adaptativa
  - Interfaz intuitiva y moderna
  - Sin almacenamiento permanente
  
  #### üõ°Ô∏è Seguridad:
  - Las contrase√±as se generan localmente
  - No se env√≠an datos a servidores externos
  - Historial solo durante la sesi√≥n
  - C√≥digo abierto y auditable
  
  **Versi√≥n**: 1.0.0 | **Desarrollado con**: Streamlit + Python
  """)

# Footer final
st.markdown("---")
st.markdown("""
<div style="text-align: center; color: #666;">
  <p>üîê SmartPass AI - Generador Inteligente de Contrase√±as</p>
  <p>Desarrollado con ‚ù§Ô∏è usando Streamlit | ¬© 2024</p>
</div>
""", unsafe_allow_html=True)
